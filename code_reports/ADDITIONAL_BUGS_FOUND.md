# Additional Critical Bugs Found in Collision Resolution

## Summary

Found and fixed **2 more critical bugs** that were causing invalid plans to be silently accepted:

1. **simulate_plan() doesn't validate moves** - Creates invalid trajectories without checking bounds or obstacles
2. **No validation that spliced plans are continuous** - Prefix might not connect properly to joint A* segment

---

## Bug #5: Unvalidated Plan Simulation (CRITICAL)

**Location:** `utils/env_utils.py:26-51`

### The Problem

The `simulate_plan()` function blindly applies actions without any validation:

```python
# WRONG - original code
for action in plan:
    move = movements[action]
    new_pos = current_pos[0] + move[0], current_pos[1] + move[1]
    current_pos = new_pos
    trajectory.append(current_pos)  # Added even if invalid!
```

This means:
- Agents can move **out of bounds** → Invalid positions like (-1, 5)
- Agents can move **into obstacles** → No detection
- **Invalid trajectories are silently created** and used in collision detection

### Why This Breaks Collision Resolution

When the joint A* planner generates a new segment and we splice it with an old plan:

```
old_plan = [action1, action2, ..., action_k]  (from neural network, might be suboptimal)
t_start = 5
joint_segment = [15 actions from A*]  (guaranteed valid for the reachable cells)

new_plan = old_plan[:5] + joint_segment + old_plan[20:]
```

If `old_plan[:5]` happens to move the agent out of bounds or into an obstacle, `simulate_plan()` silently accepts it! The trajectory will have invalid positions like:
- `(-1, 2)` - outside the grid
- `(3, 3)` - an obstacle cell marked as -1

Then when collision detection runs:
```python
# In analyze_collisions()
if static_grid[r, c] == -1:
    collision_detected = True
```

If `r` is -1 (out of bounds), the condition `0 <= r < rows` fails, so the obstacle collision is **not detected**!

### Example Failure Scenario

```
Grid: 11x11, Obstacles at (5,5)
Agent 1 original plan from neural network: [1, 1, 0, 0, ...]
  (1,1)→(2,1)→(2,2)→(1,2)→(0,2)... valid

At t_start=8, after collision resolution, the agent position is different
We splice: plan[:8] + joint_A*_segment + plan[15:]

When simulating:
  Position at t=8: (0,0)
  Actions 8-10: [1, 1, 0]  (UP, UP, UP from neural network)
  Step 8: (0,0) + (−1,0) = (−1,0) ✗ OUT OF BOUNDS
  Step 9: (−1,0) + (−1,0) = (−2,0) ✗ OUT OF BOUNDS
  Step 10: (−2,0) + (−1,0) = (−3,0) ✗ OUT OF BOUNDS

Trajectory created: [..., (0,0), (-1,0), (-2,0), (-3,0), ...]

Collision detection doesn't flag this as invalid!
```

### The Fix

Now `simulate_plan()` validates every move:

```python
# Check bounds
if not (0 <= r < rows and 0 <= c < cols):
    print(f"Move out of bounds at step {action_idx}: {current_pos} + {move} = {new_pos}")
    return None  # Reject the plan

# Check obstacle
if grid[r, c] == -1:
    print(f"Move into obstacle at step {action_idx}: {new_pos}")
    return None  # Reject the plan
```

**Impact:** Now invalid plans are rejected immediately instead of creating garbage trajectories that confuse collision detection.

---

## Bug #6: Unvalidated Plan Splicing (CRITICAL)

**Location:** `fix.py:1041-1085`

### The Problem

When we splice a joint A* plan segment with the old plan prefix, we don't verify that they connect properly:

```python
# WRONG - original code
prefix_actions = current_plans[idx][:t_start]
new_full_plan = prefix_actions + plan_segment + original_suffix

# Then immediately simulate the full plan
sim_env = copy.deepcopy(agent_envs[idx])
sim_env.env.agent_pos = agent_starts[idx]
new_traj = simulate_plan(sim_env, new_full_plan)
```

### Why This is Wrong

The prefix actions are taken from the original plan, generated by the neural network at the start. During the collision resolution process:
- Previous collision fixes may have modified agent positions
- The agent's actual trajectory at time `t_start` might be different
- The prefix might not lead to the position expected by the joint A* segment

**Example:**

```
Initial plan for Agent 1: [1, 3, 3, 2, 0, ...]  (10 actions total)
Initial trajectory: [(3,2), (4,2), (4,3), (4,4), (4,3), (3,3), ...]

After collision resolutions in passes 1-5:
  Current plan: [1, 3, 3, 2, 0, ...]  (unchanged)
  Current trajectory: [(3,2), (4,2), (4,3), (5,4), (6,4), (6,3), ...]  (different!)

In pass 6, joint A* is triggered at t=5:
  t_start = 5
  prefix_actions = current_plans[0][:5] = [1, 3, 3, 2, 0]

  Simulating prefix from agent_starts[0] = (3,2):
    (3,2) + [1,3,3,2,0] → [..., (5,4)]  <- prefix ends here

  But current_trajectories[0][5] = (6,4)  <- joint A* expects to start here!

  MISMATCH: Prefix ends at (5,4), but joint A* segment was planned from (6,4)

  Result: The spliced plan is disconnected! Agent jumps from (5,4) to (6,4) instantly.
```

### Impact on Collision Detection

A discontinuous plan can cause:
1. **Agents jumping across the grid** without following a valid path
2. **Undetected collisions** - the position jump might pass through other agents
3. **Unrealistic trajectories** - the agent appears in impossible positions
4. **Collision detection only reporting subset of collisions** - because actual collisions are masked by the simulation error

This explains why you're seeing only 1 collision reported when the plans have "many issues" - the collision detection is working on invalid/discontinuous trajectories!

### The Fix

Now we validate the boundary before splicing:

```python
# BUGFIX: Validate that prefix leads to the expected joint A* start position
if t_start > 0 and prefix_actions:
    # Simulate just the prefix to see where it ends
    prefix_env = copy.deepcopy(agent_envs[idx])
    prefix_env.env.agent_pos = agent_starts[idx]
    prefix_traj = simulate_plan(prefix_env, prefix_actions)

    if prefix_traj is None:
        print(f"ERROR: Prefix for agent {aid} is invalid")
        joint_success = False
        break

    prefix_end_pos = tuple(map(int, prefix_traj[-1]))
    expected_segment_start = tuple(map(int, current_trajectories[idx][t_start]))

    if prefix_end_pos != expected_segment_start:
        print(f"ERROR: Prefix ends at {prefix_end_pos} but segment expects {expected_segment_start}")
        joint_success = False
        break  # Reject this splice
```

Also enhanced the post-splice validation:
```python
if not new_traj:
    print(f"ERROR: Simulating spliced plan for agent {aid} failed")
    joint_success = False
    break  # Reject invalid spliced plan
```

---

## Root Cause Analysis

These bugs interacted to hide each other:

1. **Bug #5** (unvalidated simulate_plan): Allowed invalid trajectories to be silently created
2. **Bug #6** (unvalidated splicing): Created disconnected plans that should have failed
3. **Lax collision detection**: Couldn't properly validate trajectories with out-of-bounds positions
4. **Over-lenient acceptance criteria**: Accepted solutions that reduced collision count even if new collisions appeared

### Why Only 1 Collision Reported?

In your test run:
- Passes 1-5: Resolve individual collisions
- Pass 6: Joint A* on agents 3-5 generates 15-step plans
- These spliced plans have issues (boundary discontinuities, invalid moves)
- When simulated, they produce garbage trajectories
- Collision detection runs on these garbage trajectories
- Reports only the obvious collision (agents 1-7) that exists despite the errors
- **Misses collisions** that are hidden by the invalid trajectory data

---

## What To Do Now

Run the test again with the fixed code:

```bash
python run_exp.py --strategy best --info all --search_type astar --algo dqn \
  --map_file test_data/maps/maps_11x11/map_7_2.txt --timeout 120
```

You should now see:
- More descriptive error messages about invalid moves
- Joint A* splicing failures when boundaries don't match
- Potentially more collisions being reported (since they're now properly detected)
- OR the algorithm finding fewer but truly valid solutions

The validation is now **strict**, which means:
- More splices might fail (good - they were invalid)
- Plans that pass validation are actually correct
- Collision count at the end reflects real collisions, not measurement errors

---

## Files Modified

- `utils/env_utils.py` - Added move validation to simulate_plan()
- `fix.py` - Added prefix/segment boundary validation before splicing

---

## Testing Verification

The code now:
1. ✅ Rejects plans that move agents out of bounds
2. ✅ Rejects plans that move agents into obstacles
3. ✅ Rejects spliced plans with discontinuous boundaries
4. ✅ Reports actual simulation errors instead of silently accepting garbage

You can identify issues by looking for:
- `[simulate_plan] Move out of bounds` messages
- `[simulate_plan] Move into obstacle` messages
- `ERROR: Prefix for agent... is invalid`
- `ERROR: Prefix ends at... but segment expects...`
